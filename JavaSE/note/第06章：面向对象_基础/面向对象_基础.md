# 1. 类的成员

## 1.1. 类的成员之一：成员变量（field）

### 1.1.1. 简介

* **格式**

  ```java
  [修饰符 1] class 类名{
   [修饰符 2] 数据类型 成员变量名 [= 初始化值];
  }
  ```

* **总结**

  *  位置要求
    
    * 必须在类中，方法外
  * 修饰符  
    * 常用的权限修饰符有：private、缺省、protected、public
  * 其他修饰符：static、final 
  
* 数据类型
  
  * 任何基本数据类型(如 int、Boolean) 或 任何引用数据类型
  
* 成员变量名
  
  * 属于标识符，符合命名规则和规范即可
  
* 初始化值
  
  * 根据情况，可以显式赋值；也可以不赋值，使用默认值
  
      

### 1.1.2. 变量的分类

![图片](https://dawn1314.oss-cn-beijing.aliyuncs.com/typoraimg/202311161551578.png)

* 简介

  * 成员变量: 在方法体外，类体内声明的变量称为成员变量
  * 局部变量: 在方法体内部等位置声明的变量称为局部变量

  > static 可以将成员变量分为两大类，静态变量和非静态变量。其中静态变量又称为类变量，非静态变量又称为实例变量或者属性。

* 相同点
  * 变量声明的格式相同： 数据类型 变量名 = 初始化值
  * 变量必须先声明、后初始化、再使用
  * 变量都有其对应的作用域。只在其作用域内是有效的
* 不同点
  * 声明位置和方式 
    * 实例变量：在类中方法外 
    * 局部变量：在方法体{}中或方法的形参列表、代码块中
  * 在内存中存储的位置不同
    * 实例变量：堆
    * 局部变量：栈
  * 生命周期
    * 实例变量：和对象的生命周期一样，随着对象的创建而存在，随着对象被 GC 回收而消亡， 而且每一个对象的实例变量是独立的
    * 实例变量：和对象的生命周期一样，随着对象的创建而存在，随着对象被 GC 回收而消亡， 而且每一个对象的实例变量是独立的
  * 作用域 
    * 实例变量：通过对象就可以使用，本类中直接调用，其他类中“对象.实例变量” 
    * 局部变量：出了作用域就不能使用
  * 修饰符
    * 实例变量: public,protected,private,final,volatile,transient 等
    * 局部变量：final
  * 默认值
    * 实例变量：有默认值
    * 局部变量：没有，必须手动初始化。其中的形参比较特殊，靠实参给它初始化



## 1.2. 类的成员之二：方法（method）

### 1.2.1. 形参和实参 

* 形参（formal parameter）：在定义方法时，方法名后面括号()中声明的变量称为形式参数，简称形参
* 实参（actual parameter）：在调用方法时，方法名后面括号()中的使用的值/变量/表达式称为实际参数，简称实参



### 1.2.2. 参数传递机制：值传递

* Java 里方法的参数传递方式只有一种：值传递。 即将实际参数值的副本（复制品）传入方法内，而参数本身不受影响

* 形参是基本数据类型：将实参基本数据类型变量的“数据值”传递给形参

* 形参是引用数据类型：将实参引用数据类型变量的“地址值”传递给形参



## 1.3. 类的成员之三：构造器（constructor）

* **格式**

  ```java
  [修饰符] class 类名{
   [修饰符] 构造器名(){
   // 实例初始化代码
   }
   [修饰符] 构造器名(参数列表){
   // 实例初始化代码
   }
  }
  ```

* **总结**
  *  构造器名必须与它所在的类名必须相同
  * 它没有返回值，所以不需要返回值类型，也不需要 void
  * 构造器的修饰符只能是权限修饰符，不能被其他任何修饰。比如，不能被 static、final、synchronized、abstract、native 修饰，不能有 return 语句返回值。



# 2. 面向对象特征

## 2.1. 面向对象特征一: 封装性(encapsulation)

|  修饰符   | 本类内部 | 本包内 | 其他包的子类 | 其他包的非子类 |
| :-------: | :------: | :----: | :----------: | :------------: |
|  private  |    √     |   ×    |      ×       |       ×        |
|   缺省    |    √     |   √    |      ×       |       ×        |
| protected |    √     |   √    |      √       |       ×        |
|  public   |    √     |   √    |      √       |       √        |



## 2.2. **面向对象特征二：继承(Inheritance)** 

* 简介

  * 多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类中无需再定义这些属性和行为，只需要和抽取出来的类构成继承关系

* 优点

  * 继承的出现减少了代码冗余，提高了代码的复用性

  * 继承的出现，更有利于功能的扩展 

  * 继承的出现让类与类之间产生了 `is-a` 的关系，为多态的使用提供了前提

  * 继承描述事物之间的所属关系，这种关系是：is-a 的关系。可见，父类

    更通用、更一般，子类更具体

* 语法格式

  通过 `extends `关键字，可以声明一个类 B 继承另外一个类 A，定义格式如下

  ```java
  [修饰符] class 类 A {
  ...
  }
  [修饰符] class 类 B extends 类 A {
  ...
  }
  ```

* 基本概念

  * 类 B，称为子类、派生类(derived class)、SubClass
  * 类 A，称为父类、超类、基类(base class)、SuperClass

* 总结

  * **子类会继承父类所有的实例变量和实例方法**

    从类的定义来看，类是一类具有相同特性的事物的抽象描述。父类是所有子类共同特征的抽象描述。而实例变量和实例方法就是事物的特征，那么父类中声明的实例变量和实例方法代表子类事物也有这个特征

  * **子类不能直接访问父类中私有的(private)的成员变量和方法**

    子类虽会继承父类私有(private)的成员变量，但子类不能对继承的私有成员变量直接进行访问，可通过继承的 get/set 方法进行访问

  * **在 Java 中，继承的关键字用的是“extends”，即子类不是父类的子集，而是对父类的“扩展**

    子类在继承父类以后，还可以定义自己特有的方法，这就可以看做是对父类功能上的扩展

  * **所有的类默认继承 Object，作为父类**
  * **一个父类可以同时拥有多个子类**
  * **Java 只支持单继承，不支持多重继承**

  

# 3. 关键字

## 3.1. 关键字: package

* **简介**
  * package，称为包，用于指明该文件中定义的类、接口等结构所在的包

* **总结**
  * 一个源文件只能有一个声明包的 package 语句
  * package 语句作为 Java 源文件的第一条语句出现。若缺省该语句，则指定为无名包 
  * 包名，属于标识符，满足标识符命名的规则和规范（全部小写）、见名知意
    * 包通常使用所在公司域名的倒置：com.atguigu.xxx。
    * 大家取包名时不要使用"*java.xx*"包
    * 包对应于文件系统的目录，package 语句中用 “.” 来指明包(目录)的层次，每"."一次就表示一层文件目录。
    * 同一个包下可以声明多个结构（类、接口），但是不能定义同名的结构（类、接口）
    * 不同的包下可以定义同名的结构（类、接口）



## 3.2. 关键字: import

* **简介**
  
* 为了使用定义在其它包中的 Java 类，需用 import 语句来显式引入指定包下所需要的类。相当于 import 语句告诉编译器到哪里去寻找这个类
  
* 总结

  * import 语句，声明在包的声明和类的声明之间

  * 如果需要导入多个类或接口，那么就并列显式多个 import 语句即可 

  * 如果使用 `*a.**`导入结构，表示可以导入 a 包下的所有的结构。举例：可以使用

    java.util.*的方式，一次性导入 util 包下所有的类或接口

  * **如果导入的类或接口是 java.lang 包下的，或者是当前包下的，则可以省略此 import语句**

  * 如果已经导入 java.a 包下的类，那么如果需要使用 a 包的子包下的类的话，仍然需要

    导入

  * 如果在代码中使用不同包下的同名的类，那么就需要使用类的全类名的方式指明调用的是哪个类。

  * `import static` 组合的使用：调用指定类或接口下的静态的属性或方法



## 3.2. 关键字: this

### 3.2.1. 简介

* 它在方法（准确的说是实例方法或非 static 的方法）内部使用，表示调用该方法的对象

* 它在构造器内部使用，表示该构造器正在初始化的对象

* this 可以调用的结构：成员变量、方法和构造器

  

### 3.2.1. 使用

* **实例方法或构造器中使用当前对象的成员**
  * 在实例方法或构造器中，如果使用当前类的成员变量或成员方法可以在其前面添加 this，增强程序的可读性。不过，通常我们都习惯省略 this
  
  * 但是，当形参与成员变量同名时，如果在方法内或构造器内需要使用成员变量，必须添加 this 来表明该变量是类的成员变量。即：我们可以用 this 来区分成员变量和局部变量. 
  
  * 使用 this 访问属性和方法时，如果在本类中未找到，会从父类中查找
  

* **同一个类中构造器中互相调用**

  * 方式
    * **`this()`**：调用本类的无参构造器
    * **`this(实参列表)`**：调用本类的有参构造器
  * 总结
    * 不能出现递归调用。比如，调用自身构造器. 即**如果一个类中声明了 n 个构造器，则最多有 n - 1 个构造器中使用了"this(形参列表)"**
    * this()和 this(实参列表)只能声明在构造器首行. 即, **在类的一个构造器中，最多只能声明一个"this(参数列表)"**

  ```java
  public class Student {
      private String name;
      private int age;
      // 无参构造
      public Student() {
        // this("",18);//调用本类有参构造器
      }
      
      // 有参构造
      public Student(String name) {
          this();//调用本类无参构造器
          this.name = name;
      }
      
      // 有参构造
      public Student(String name,int age){
          this(name);//调用本类中有一个 String 参数的构造器
          this.age = age;
      }
      public String getName() {
          return name;
      }
      public void setName(String name) {
          this.name = name;
      }
      public int getAge() {
          return age;
      }
      public void setAge(int age) {
          this.age = age;
      }
      public String getInfo(){
          return "姓名：" + name +"，年龄：" + age;
      }
  }
  ```

  

# 4. 匿名对象

* **简介**
  * 我们也可以不定义对象的句柄，而直接调用这个对象的方法。这样的对象叫做匿名对象

* **总结**
  * 如果一个对象只需要进行一次方法调用，那么就可以使用匿名对象
  * 我们经常将匿名对象作为实参传递给一个方法调用



# 5. 赋值过程

* **(1) **默认初始化 **-->** **(2)** 显式初始化 **-->** **(3)** 构造器中初始化 **-->** **(4) **通过"对象.属性"或"对象.方法"的方式，给属性赋值



# 6. 方法的重写

* 简介

  子类可以对从父类中继承来的方法进行改造，我们称为方法的重写* (override、overwrite)。也称为方法的重置、覆盖。在程序执行时，子类的方法将覆盖父类的方法

* 要求

  * 子类重写的方法必须和父类被重写的方法具有相同的方法名称、参数列表

  * 子类重写的方法的返回值类型不能大于父类被重写的方法的返回值类型。（例如：Student < Person）

     注意：如果返回值类型是基本数据类型和 void，那么必须是相同

  * 子类重写的方法使用的访问权限不能小于父类被重写的方法的访问权限。（public > protected > 缺省 > private）

    注意：① 父类私有方法不能重写 ② 跨包的父类缺省的方法也不能重写 

  * 子类方法抛出的异常不能大于父类被重写方法的异常
  * 子类与父类中同名同参数的方法必须同时声明为非 static 的(即为重写)，或者同时声明为 static 的（不是重写）。因为 static 方法是属于类的，子类无法覆盖父类的方法
