# 1. 类的成员

## 1.1. 类的成员之一：成员变量（field）

### 1.1.1. 简介

* **格式**

  ```java
  [修饰符 1] class 类名{
   [修饰符 2] 数据类型 成员变量名 [= 初始化值];
  }
  ```

* **总结**

  *  位置要求
    * 必须在类中，方法外
  * 修饰符  
    * 常用的权限修饰符有：private、缺省、protected、public
    * 其他修饰符：static、final 

  * 数据类型

    * 任何基本数据类型(如 int、Boolean) 或 任何引用数据类型

  * 成员变量名

    * 属于标识符，符合命名规则和规范即可

  * 初始化值

    * 根据情况，可以显式赋值；也可以不赋值，使用默认值

      

### 1.1.2. 变量的分类

![图片](https://dawn1314.oss-cn-beijing.aliyuncs.com/typoraimg/202311161551578.png)

* 简介

  * 成员变量: 在方法体外，类体内声明的变量称为成员变量
  * 局部变量: 在方法体内部等位置声明的变量称为局部变量

  > static 可以将成员变量分为两大类，静态变量和非静态变量。其中静态变量又称为类变量，非静态变量又称为实例变量或者属性。

* 相同点
  * 变量声明的格式相同： 数据类型 变量名 = 初始化值
  * 变量必须先声明、后初始化、再使用
  * 变量都有其对应的作用域。只在其作用域内是有效的
* 不同点
  * 声明位置和方式 
    * 实例变量：在类中方法外 
    * 局部变量：在方法体{}中或方法的形参列表、代码块中
  * 在内存中存储的位置不同
    * 实例变量：堆
    * 局部变量：栈
  * 生命周期
    * 实例变量：和对象的生命周期一样，随着对象的创建而存在，随着对象被 GC 回收而消亡， 而且每一个对象的实例变量是独立的
    * 实例变量：和对象的生命周期一样，随着对象的创建而存在，随着对象被 GC 回收而消亡， 而且每一个对象的实例变量是独立的
  * 作用域 
    * 实例变量：通过对象就可以使用，本类中直接调用，其他类中“对象.实例变量” 
    * 局部变量：出了作用域就不能使用
  * 修饰符
    * 实例变量: public,protected,private,final,volatile,transient 等
    * 局部变量：final
  * 默认值
    * 实例变量：有默认值
    * 局部变量：没有，必须手动初始化。其中的形参比较特殊，靠实参给它初始化



## 1.2. 类的成员之二：方法（method）

### 1.2.1. 形参和实参 

* 形参（formal parameter）：在定义方法时，方法名后面括号()中声明的变量称为形式参数，简称形参
* 实参（actual parameter）：在调用方法时，方法名后面括号()中的使用的值/变量/表达式称为实际参数，简称实参



### 1.2.2. 参数传递机制：值传递

* Java 里方法的参数传递方式只有一种：*值传递*。 即将实际参数值的副本（复制品）传入方法内，而参数本身不受影响

* 形参是基本数据类型：将实参基本数据类型变量的“数据值”传递给形参

* 形参是引用数据类型：将实参引用数据类型变量的“地址值”传递给形参



## 1.3. 类的成员之三：构造器（constructor）

* **格式**

  ```java
  [修饰符] class 类名{
   [修饰符] 构造器名(){
   // 实例初始化代码
   }
   [修饰符] 构造器名(参数列表){
   // 实例初始化代码
   }
  }
  ```

* **总结**
  *  构造器名必须与它所在的类名必须相同
  * 它没有返回值，所以不需要返回值类型，也不需要 void
  * 构造器的修饰符只能是权限修饰符，不能被其他任何修饰。比如，不能被 static、final、synchronized、abstract、native 修饰，不能有 return 语句返回值。



# 2. 面向对象特征

## 2.1. 面向对象特征一: 封装性(encapsulation)

|  修饰符   | 本类内部 | 本包内 | 其他包的子类 | 其他包的非子类 |
| :-------: | :------: | :----: | :----------: | :------------: |
|  private  |    √     |   ×    |      ×       |       ×        |
|   缺省    |    √     |   √    |      ×       |       ×        |
| protected |    √     |   √    |      √       |       ×        |
|  public   |    √     |   √    |      √       |       √        |



# 3. 关键字

## 3.1. 关键字: package

* **简介**
  * package，称为包，用于指明该文件中定义的类、接口等结构所在的包

* **总结**
  * 一个源文件只能有一个声明包的 package 语句
  * package 语句作为 Java 源文件的第一条语句出现。若缺省该语句，则指定为无名包 
  * 包名，属于标识符，满足标识符命名的规则和规范（全部小写）、见名知意
    * 包通常使用所在公司域名的倒置：com.atguigu.xxx。
    * 大家取包名时不要使用"*java.xx*"包
    * 包对应于文件系统的目录，package 语句中用 “.” 来指明包(目录)的层次，每"."一次就表示一层文件目录。
    * 同一个包下可以声明多个结构（类、接口），但是不能定义同名的结构（类、接口）
    * 不同的包下可以定义同名的结构（类、接口）



## 3.2. 关键字: import

* **简介**
  * 为了使用定义在其它包中的 Java 类，需用 import 语句来显式引入指定包下所需要的类。相当于 import 语句告诉编译器到哪里去寻找这个类

* 总结

  * import 语句，声明在包的声明和类的声明之间

  * 如果需要导入多个类或接口，那么就并列显式多个 import 语句即可 

  * 如果使用 `*a.**`导入结构，表示可以导入 a 包下的所有的结构。举例：可以使用

    java.util.*的方式，一次性导入 util 包下所有的类或接口

  * **如果导入的类或接口是 java.lang 包下的，或者是当前包下的，则可以省略此 import语句**

  * 如果已经导入 java.a 包下的类，那么如果需要使用 a 包的子包下的类的话，仍然需要

    导入

  * 如果在代码中使用不同包下的同名的类，那么就需要使用类的全类名的方式指明调用的是哪个类。

  * `import static` 组合的使用：调用指定类或接口下的静态的属性或方法



# 4. 匿名对象

* **简介**
  * 我们也可以不定义对象的句柄，而直接调用这个对象的方法。这样的对象叫做匿名对象

* **总结**
  * 如果一个对象只需要进行一次方法调用，那么就可以使用匿名对象
  * 我们经常将匿名对象作为实参传递给一个方法调用



# 5. 赋值过程

* **(1) **默认初始化 **-->** **(2)** 显式初始化 **-->** **(3)** 构造器中初始化 **-->** **(4) **通过"对象.属性"或"对象.方法"的方式，给属性赋值
